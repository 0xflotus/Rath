{"version":3,"sources":["../webpack/bootstrap","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../../../node_modules/cube-core/built/index.js","../../../node_modules/cube-core/built/utils/aggregation.js","../../../node_modules/cube-core/built/core/index.js","../../../node_modules/cube-core/built/core/periodCube.js","../../../node_modules/cube-core/built/core/momentCube.js","../../../node_modules/cube-core/built/utils/transform.js","../../../node_modules/regenerator-runtime/runtime.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../visual-insights/build/esm/utils/common.js","../../visual-insights/build/esm/distribution.js","../../visual-insights/build/esm/statistics/utils.js","../../visual-insights/build/esm/ml/cluster/kruskal.js","../../visual-insights/build/esm/insights/dev.js","../../visual-insights/build/esm/univariateSummary/index.js","workers/timer.js","workers/groupFields.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","this","__assign","index_1","require","transform_1","aggregation_1","operatorMap","sum_unsafe","mean","count","createCube","_a","type","_b","aggFunc","_c","factTable","_d","dimensions","_e","measures","periodCube","momentCube","default","props","asFields","operator","dataSource","cube","table","tree2Table","forEach","row","as","__export","subset","sums","mea","_loop_1","len","length","sum","_loop_2","Number","MEASURES","cnts","_loop_3","periodCube_1","momentCube_1","__read","iterator","e","ar","next","done","push","error","__spread","arguments","concat","__values","TypeError","Node","children","Map","_rawData","cache","params","_i","apply","aggData","_aggData","rawData","clearCache","e_1","size","values","children_1","children_1_1","child","data","e_1_1","return","configurable","getNode","search","node","level","e_2","entries","children_2","children_2_1","childName","e_2_1","tree","e_3","children_3","children_3_1","e_3_1","buildTree","insertNode","record","member","has","set","aggTree","e_4","children_4","children_4_1","e_4_1","aggNode","e_5","children_5","children_5_1","e_5_1","setData","assign","dfs","runtime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","tryCatch","makeInvokeMethod","fn","obj","err","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","Promise","resolve","reject","invoke","result","__await","then","unwrapped","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","_defineProperty","writable","_toConsumableArray","arr","Array","isArray","arr2","from","deepcopy","JSON","parse","stringify","memberCount","field","counter","groupContinousField","newField","groupNumber","map","item","max","Math","min","segWidth","ranges","left","right","Infinity","precision","log10","abs","rangeIndex","findIndex","range","toPrecision","groupCategoryField","members","sort","a","b","v","Set","add","isUniformDistribution","every","normalize","frequencyList","f","entropy","probabilityList","log2","turnAdjMatrix2List","matrix","edges","j","find","parents","union","n1","n2","p1","p2","findWithEffect","sizes","unionWithEffect","size1","size2","kruskalMST","threshold","edgesInMST","groups","inCutEdge","edge","cluster","groupMaxSize","limitSize","kruskalWithLimitSize","kruskal","ans","meas","meaIndex","DefaultIWorker","getFieldType","fieldName","Date","test","isFieldTime","isFieldContinous","isFieldCategory","getAllFieldTypes","fields","fieldsWithType","getFieldDistribution","memberName","getAllFieldsDistribution","fieldsDistribution","distribution","getFieldEntropy","maxEntropy","getAllFieldsEntropy","fieldEntropyList","groupFields","groupedData","newFields","newFieldName","MIN_QUAN_MEMBER_SIZE","task","addEventListener","postMessage","success","message","startTime","getTime","cost","console","log"],"mappings":"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","file":"a052c681f648b70eb30e.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","module.exports = require(\"regenerator-runtime\");\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar index_1 = require(\"./core/index\");\n// import { JsonRecord } from './types';\nvar transform_1 = require(\"./utils/transform\");\nvar aggregation_1 = require(\"./utils/aggregation\");\nvar operatorMap = {\n    'sum': aggregation_1.sum_unsafe,\n    'mean': aggregation_1.mean,\n    'count': aggregation_1.count,\n};\nfunction copyDataSource(data) {\n    return data.map(function (row) {\n        return __assign({}, row);\n    });\n}\nfunction aggregate(props) {\n    var dimensions = props.dimensions, measures = props.measures, asFields = props.asFields, operator = props.operator, dataSource = props.dataSource;\n    var data = [];\n    var cube = createCube({\n        type: 'moment',\n        aggFunc: operatorMap[operator] || aggregation_1.count,\n        dimensions: dimensions,\n        measures: measures,\n        factTable: dataSource\n    });\n    var table = transform_1.tree2Table({ dimensions: dimensions, measures: measures, cube: cube });\n    table.forEach(function (row) {\n        asFields.forEach(function (as, i) {\n            row[as] = row[measures[i]];\n        });\n    });\n    return table;\n}\nfunction createCube(_a) {\n    var type = _a.type, _b = _a.aggFunc, aggFunc = _b === void 0 ? aggregation_1.count : _b, _c = _a.factTable, factTable = _c === void 0 ? [] : _c, _d = _a.dimensions, dimensions = _d === void 0 ? [] : _d, _e = _a.measures, measures = _e === void 0 ? [] : _e;\n    switch (type) {\n        case \"period\":\n            return new index_1.periodCube({\n                aggFunc: aggFunc,\n                factTable: factTable,\n                dimensions: dimensions,\n                measures: measures\n            });\n        case \"moment\":\n            return new index_1.momentCube({\n                aggFunc: aggFunc,\n                factTable: factTable,\n                dimensions: dimensions,\n                measures: measures\n            });\n        default:\n            return new index_1.momentCube({\n                aggFunc: aggFunc,\n                factTable: factTable,\n                dimensions: dimensions,\n                measures: measures\n            });\n    }\n}\nexports.createCube = createCube;\nexports.default = aggregate;\n__export(require(\"./utils/aggregation\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sum_unsafe = function (subset, measures) {\n    var sums = {};\n    measures.forEach(function (mea) {\n        sums[mea] = 0;\n    });\n    var _loop_1 = function (i, len) {\n        measures.forEach(function (mea) {\n            sums[mea] += subset[i][mea];\n        });\n    };\n    for (var i = 0, len = subset.length; i < len; i++) {\n        _loop_1(i, len);\n    }\n    return sums;\n};\nexports.sum = function (subset, measures) {\n    var sums = {};\n    measures.forEach(function (mea) {\n        sums[mea] = 0;\n    });\n    var _loop_2 = function (i, len) {\n        measures.forEach(function (mea) {\n            sums[mea] += Number(subset[i][mea]) || 0;\n        });\n    };\n    for (var i = 0, len = subset.length; i < len; i++) {\n        _loop_2(i, len);\n    }\n    return sums;\n};\nexports.count = function (subset, MEASURES) {\n    var cnts = {};\n    MEASURES.forEach(function (mea) {\n        cnts[mea] = 0;\n    });\n    for (var i = 0, len = subset.length; i < len; i++) {\n        MEASURES.forEach(function (mea) {\n            cnts[mea]++;\n        });\n    }\n    return cnts;\n};\nexports.mean = function (subset, measures) {\n    var sums = {};\n    measures.forEach(function (mea) {\n        sums[mea] = 0;\n    });\n    var _loop_3 = function (i, len) {\n        measures.forEach(function (mea) {\n            sums[mea] += Number(subset[i][mea]) || 0;\n        });\n    };\n    for (var i = 0, len = subset.length; i < len; i++) {\n        _loop_3(i, len);\n    }\n    measures.forEach(function (mea) {\n        sums[mea] /= subset.length;\n    });\n    return sums;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar periodCube_1 = require(\"./periodCube\");\nexports.periodCube = periodCube_1.default;\nvar momentCube_1 = require(\"./momentCube\");\nexports.momentCube = momentCube_1.default;\n","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Node = /** @class */ (function () {\n    function Node(aggFunc) {\n        this.children = new Map();\n        this._rawData = [];\n        this.aggFunc = aggFunc;\n        this.cache = false;\n    }\n    Node.prototype.push = function () {\n        var _a;\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n        }\n        (_a = this._rawData).push.apply(_a, __spread(params));\n    };\n    Node.prototype.aggData = function (measures) {\n        if (measures === void 0) { measures = []; }\n        if (!this.cache) {\n            this._aggData = this.aggFunc(this.rawData, measures);\n            this.cache = true;\n        }\n        return this._aggData;\n    };\n    Node.prototype.clearCache = function () {\n        this.cache = false;\n    };\n    Object.defineProperty(Node.prototype, \"rawData\", {\n        get: function () {\n            var e_1, _a;\n            if (!this.cache) {\n                if (this.children.size !== 0) {\n                    var children = this.children.values();\n                    var rawData = [];\n                    try {\n                        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n                            var child = children_1_1.value;\n                            var i = void 0;\n                            var data = child.rawData;\n                            var len = data.length;\n                            for (i = 0; i < len; i++) {\n                                rawData.push(data[i]);\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    this._rawData = rawData;\n                }\n                this.cache = true;\n            }\n            return this._rawData;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.getNode = function (dimensions) {\n        var search = function (node, level) {\n            var e_2, _a;\n            if (level === dimensions.length) {\n                return node;\n            }\n            var children = node.children.entries();\n            try {\n                for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {\n                    var _b = __read(children_2_1.value, 2), childName = _b[0], child = _b[1];\n                    if (childName === dimensions[level]) {\n                        return search(child, level + 1);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (children_2_1 && !children_2_1.done && (_a = children_2.return)) _a.call(children_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return null;\n        };\n        return search(this, 0);\n    };\n    return Node;\n}());\nvar periodCube = /** @class */ (function () {\n    function periodCube(props) {\n        this.aggFunc = props.aggFunc;\n        this.factTable = props.factTable;\n        this.dimensions = props.dimensions;\n        this.measures = props.measures;\n    }\n    periodCube.prototype.get = function (dimensions) {\n        var _a = this, tree = _a.tree, aggFunc = _a.aggFunc, measures = _a.measures;\n        var search = function (node, level) {\n            var e_3, _a;\n            if (level === dimensions.length) {\n                return node.aggData(measures);\n            }\n            var children = node.children.entries();\n            try {\n                for (var children_3 = __values(children), children_3_1 = children_3.next(); !children_3_1.done; children_3_1 = children_3.next()) {\n                    var _b = __read(children_3_1.value, 2), childName = _b[0], child = _b[1];\n                    if (childName === dimensions[level]) {\n                        return search(child, level + 1);\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (children_3_1 && !children_3_1.done && (_a = children_3.return)) _a.call(children_3);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            return false;\n        };\n        return search(tree, 0);\n    };\n    periodCube.prototype.getNode = function (dimensions) {\n        var tree = this.tree;\n        return tree.getNode(dimensions);\n    };\n    periodCube.prototype.buildTree = function () {\n        var tree = new Node(this.aggFunc);\n        var len = this.factTable.length, i;\n        for (i = 0; i < len; i++) {\n            this.insertNode(this.factTable[i], tree, 0);\n        }\n        this.tree = tree;\n        return tree;\n    };\n    periodCube.prototype.insertNode = function (record, node, level) {\n        node.push(record);\n        node.cache = false;\n        if (level < this.dimensions.length) {\n            var member = record[this.dimensions[level]];\n            if (!node.children.has(member)) {\n                node.children.set(member, new Node(this.aggFunc));\n            }\n            this.insertNode(record, node.children.get(member), level + 1);\n        }\n    };\n    periodCube.prototype.aggTree = function (node) {\n        var e_4, _a;\n        if (node === void 0) { node = this.tree; }\n        var children = node.children.values();\n        try {\n            for (var children_4 = __values(children), children_4_1 = children_4.next(); !children_4_1.done; children_4_1 = children_4.next()) {\n                var child = children_4_1.value;\n                this.aggTree(child);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (children_4_1 && !children_4_1.done && (_a = children_4.return)) _a.call(children_4);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        node.aggData(this.measures);\n        return node;\n    };\n    periodCube.prototype.aggNode = function (node) {\n        var e_5, _a;\n        if (node === void 0) { node = this.tree; }\n        var children = node.children.values();\n        try {\n            for (var children_5 = __values(children), children_5_1 = children_5.next(); !children_5_1.done; children_5_1 = children_5.next()) {\n                var child = children_5_1.value;\n                this.aggTree(child);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (children_5_1 && !children_5_1.done && (_a = children_5.return)) _a.call(children_5);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        node.aggData(this.measures);\n        return node;\n    };\n    return periodCube;\n}());\nexports.default = periodCube;\n","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Node = /** @class */ (function () {\n    function Node() {\n        this.children = new Map();\n        this.rawData = [];\n    }\n    Node.prototype.push = function () {\n        var _a;\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n        }\n        (_a = this.rawData).push.apply(_a, __spread(params));\n    };\n    Node.prototype.aggData = function (aggFunc, measures) {\n        if (measures === void 0) { measures = []; }\n        this._aggData = aggFunc(this.rawData, measures);\n        return this._aggData;\n    };\n    Node.prototype.getNode = function (dimensions) {\n        var search = function (node, level) {\n            var e_1, _a;\n            if (level === dimensions.length) {\n                return node;\n            }\n            var children = node.children.entries();\n            try {\n                for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n                    var _b = __read(children_1_1.value, 2), childName = _b[0], child = _b[1];\n                    if (childName === dimensions[level]) {\n                        return search(child, level + 1);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return null;\n        };\n        return search(this, 0);\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar momentCube = /** @class */ (function () {\n    function momentCube(props) {\n        this.aggFunc = props.aggFunc;\n        this.factTable = props.factTable;\n        this.dimensions = props.dimensions;\n        this.measures = props.measures;\n        this.buildTree();\n        this.aggTree();\n    }\n    momentCube.prototype.get = function (dimensions) {\n        var _a = this, tree = _a.tree, aggFunc = _a.aggFunc, measures = _a.measures;\n        var search = function (node, level) {\n            var e_2, _a;\n            if (level === dimensions.length) {\n                return node.aggData(aggFunc, measures);\n            }\n            var children = node.children.entries();\n            try {\n                for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {\n                    var _b = __read(children_2_1.value, 2), childName = _b[0], child = _b[1];\n                    if (childName === dimensions[level]) {\n                        return search(child, level + 1);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (children_2_1 && !children_2_1.done && (_a = children_2.return)) _a.call(children_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return false;\n        };\n        return search(tree, 0);\n    };\n    momentCube.prototype.getNode = function (dimensions) {\n        var tree = this.tree;\n        return tree.getNode(dimensions);\n    };\n    momentCube.prototype.setData = function (props) {\n        var _a = props.aggFunc, aggFunc = _a === void 0 ? this.aggFunc : _a, _b = props.factTable, factTable = _b === void 0 ? this.factTable : _b, _c = props.dimensions, dimensions = _c === void 0 ? this.dimensions : _c, _d = props.measures, measures = _d === void 0 ? this.measures : _d;\n        if (dimensions !== this.dimensions || factTable !== this.factTable) {\n            this.dimensions = dimensions;\n            this.factTable = factTable;\n            this.measures = measures;\n            this.aggFunc = aggFunc;\n            this.buildTree();\n            this.aggTree();\n        }\n        else if (measures !== this.measures || aggFunc !== this.aggFunc) {\n            this.measures = measures;\n            this.aggFunc = aggFunc;\n            this.aggTree();\n        }\n    };\n    momentCube.prototype.buildTree = function () {\n        var tree = new Node();\n        var len = this.factTable.length, i;\n        for (i = 0; i < len; i++) {\n            this.insertNode(this.factTable[i], tree, 0);\n        }\n        this.tree = tree;\n        return tree;\n    };\n    momentCube.prototype.insertNode = function (record, node, level) {\n        if (level === this.dimensions.length) {\n            node.push(record);\n        }\n        else {\n            var member = record[this.dimensions[level]];\n            if (!node.children.has(member)) {\n                node.children.set(member, new Node());\n            }\n            this.insertNode(record, node.children.get(member), level + 1);\n        }\n    };\n    momentCube.prototype.aggTree = function (node) {\n        var e_3, _a;\n        if (node === void 0) { node = this.tree; }\n        if (node.children.size > 0) {\n            node.rawData = [];\n            var children = node.children.values();\n            try {\n                for (var children_3 = __values(children), children_3_1 = children_3.next(); !children_3_1.done; children_3_1 = children_3.next()) {\n                    var child = children_3_1.value;\n                    var i = void 0;\n                    var data = this.aggTree(child).rawData;\n                    var len = data.length;\n                    for (i = 0; i < len; i++) {\n                        node.rawData.push(data[i]);\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (children_3_1 && !children_3_1.done && (_a = children_3.return)) _a.call(children_3);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n        node.aggData(this.aggFunc, this.measures);\n        return node;\n    };\n    return momentCube;\n}());\nexports.default = momentCube;\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tree2Table(props) {\n    var dimensions = props.dimensions, measures = props.measures, cube = props.cube;\n    var aggFunc = cube.aggFunc;\n    var table = [];\n    function dfs(node, record, level) {\n        var e_1, _a, _b;\n        if (node.children.size === 0) {\n            var values = node._aggData;\n            table.push(__assign(__assign({}, record), values));\n            return;\n        }\n        try {\n            for (var _c = __values(node.children.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var _e = __read(_d.value, 2), childName = _e[0], child = _e[1];\n                var r = __assign(__assign({}, record), (_b = {}, _b[dimensions[level]] = childName, _b));\n                dfs(child, r, level + 1);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    dfs(cube.tree, {}, 0);\n    return table;\n}\nexports.tree2Table = tree2Table;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","const JOIN_SYMBOL = '_';\nconst MAGIC_NUMBER = 5;\nfunction deepcopy(data) {\n    return JSON.parse(JSON.stringify(data));\n}\nfunction isFieldCategory(dataSource, fieldName) {\n    return dataSource.every(record => {\n        return typeof record[fieldName] === 'string'\n            || typeof record[fieldName] === 'undefined'\n            || record[fieldName] === null;\n    });\n}\nfunction isFieldContinous(dataSource, fieldName) {\n    return dataSource.every(record => {\n        return typeof record[fieldName] === 'number'\n            || typeof record[fieldName] === 'undefined'\n            || record[fieldName] === null;\n    });\n}\nfunction isFieldNumeric(dataSource, fieldName) {\n    return dataSource.every(record => {\n        return !isNaN(record[fieldName])\n            || typeof record[fieldName] === 'undefined'\n            || record[fieldName] === null;\n    });\n}\nfunction isFieldTime(dataSource, fieldName) {\n    return dataSource.every(record => {\n        // todo: tmp solotion here.\n        if (Number(record[fieldName]) >= 1800 && Number(record[fieldName]) <= 2200) {\n            return true;\n        }\n        return (!isNaN(Date.parse(record[fieldName]))\n            && typeof record[fieldName] === 'string'\n            && /^[0-9]{0,4}[-/][0-9]{0,2}([-/][0-9]{0,2}$)?/.test(record[fieldName]))\n            || typeof record[fieldName] === 'undefined'\n            || record[fieldName] === null;\n    });\n}\nfunction aggregate({ dataSource, fields, bys, method = 'sum' }) {\n    let tmp = [];\n    for (let by of bys) {\n        let map = new Map();\n        for (let record of dataSource) {\n            let key = JSON.stringify(fields.map(field => record[field]));\n            if (!map.has(key)) {\n                map.set(key, 0);\n            }\n            map.set(key, map.get(key) + record[by]);\n        }\n        for (let [key, value] of map) {\n            let row = {\n                index: key,\n                [by]: value\n            };\n            let dims = JSON.parse(key);\n            for (let i = 0; i < fields.length; i++) {\n                row[fields[i]] = dims[i];\n            }\n            tmp.push(row);\n        }\n    }\n    let ans = new Map();\n    for (let record of tmp) {\n        if (!ans.has(record.index)) {\n            ans.set(record.index, {});\n        }\n        ans.set(record.index, { ...ans.get(record.index), ...record });\n    }\n    return [...ans.values()];\n}\nfunction memberCount(dataSource, field) {\n    const counter = new Map();\n    for (let row of dataSource) {\n        let member = row[field];\n        if (!counter.has(member)) {\n            counter.set(member, 0);\n        }\n        counter.set(member, counter.get(member) + 1);\n    }\n    return [...counter.entries()];\n}\nfunction groupContinousField({ dataSource, field, newField = `${field}(con-group)`, groupNumber }) {\n    // const members = memberCount(dataSource, field);\n    // todo: outlier detection\n    const values = dataSource.map(item => item[field]);\n    const max = Math.max(...values); // Number.EPSILON * ;\n    const min = Math.min(...values);\n    const segWidth = (max - min) / groupNumber;\n    let ranges = [];\n    for (let i = 0; i < groupNumber; i++) {\n        let left = min + i * segWidth;\n        let right = min + (i + 1) * segWidth;\n        ranges.push([left, right]);\n    }\n    ranges[0][0] = -Infinity;\n    ranges[ranges.length - 1][1] = Infinity;\n    let precision = Math.max(1, Math.log10(Math.abs(min)) - Math.log10(segWidth)) + 1;\n    for (let i = 0; i < dataSource.length; i++) {\n        let record = dataSource[i];\n        let rangeIndex = ranges.findIndex(r => (r[0] <= record[field] && record[field] < r[1]));\n        let range = ranges[rangeIndex];\n        if (typeof range !== 'undefined') {\n            record[newField] = `${rangeIndex + 1}:[${Number(range[0].toPrecision(precision))}, ${Number(range[1].toPrecision(precision))})`;\n        }\n        else {\n            record[newField] = 'null';\n        }\n    }\n    return dataSource;\n}\nfunction groupCategoryField({ dataSource, field, newField = `${field}(cat-group)`, groupNumber }) {\n    // auto category should obey Power law distrubution.\n    let members = memberCount(dataSource, field);\n    members.sort((a, b) => b[1] - a[1]);\n    let sum = members.map(v => v[1]);\n    groupNumber = members.length;\n    for (let i = sum.length - 2; i >= 0; i--) {\n        sum[i] = sum[i + 1] + sum[i];\n    }\n    for (let i = 0; i < members.length - 2; i++) {\n        // strict mode\n        // if (members[i][1] >= sum[i + 1] && members[i + 1][1] < sum[i + 2]) {\n        if (members[i][1] * MAGIC_NUMBER >= sum[i + 1] && members[i + 1][1] / MAGIC_NUMBER < sum[i + 2]) {\n            groupNumber = i + 2;\n            break;\n        }\n    }\n    // groupNumber = Math.max(Math.round(Math.sqrt(members.length)), groupNumber)\n    if (groupNumber === members.length) {\n        return dataSource.map(record => {\n            return {\n                ...record,\n                [newField]: record[field]\n            };\n        });\n    }\n    let set = new Set();\n    for (let i = groupNumber - 1; i < members.length; i++) {\n        set.add(members[i][0]);\n    }\n    for (let record of dataSource) {\n        if (set.has(record[field])) {\n            record[newField] = 'others';\n        }\n        else {\n            record[newField] = record[field];\n        }\n    }\n    return dataSource;\n}\n/**\n * Kullback–Leibler divergence\n * @param p1List\n * @param p2List\n *\n */\nfunction DKL(p1List, p2List) {\n    let sum = 0;\n    const len = Math.max(p1List.length, p2List.length);\n    for (let i = 0; i < len; i++) {\n        let p1 = p1List[i] || 0;\n        let p2 = p2List[i] || 0;\n        sum += p1 * Math.log2(p1 / p2);\n    }\n    return sum;\n}\nfunction isFieldUnique(dataSource, field) {\n    let set = new Set();\n    let validCount = 0;\n    let len = dataSource.length;\n    for (let i = 0; i < len; i++) {\n        if (dataSource[i][field] !== undefined && dataSource[i][field] !== null && dataSource[i][field] !== '') {\n            validCount++;\n            set.add(dataSource[i][field]);\n        }\n    }\n    if (set.size === validCount)\n        return true;\n    return false;\n}\nexport { deepcopy, memberCount, groupCategoryField, groupContinousField, aggregate, isFieldCategory, isFieldContinous, isFieldTime, isFieldNumeric, JOIN_SYMBOL, DKL, isFieldUnique };\n","import { memberCount } from './utils/index';\nfunction isUniformDistribution(dataSource, field) {\n    const members = memberCount(dataSource, field);\n    return members.every(member => member[1] === 1);\n}\nexport { isUniformDistribution };\n","export function linearMapPositive(arr) {\n    let min = Math.min(...arr);\n    return arr.map(a => a - min + 1);\n}\nexport function getCombination(elements, start = 1, end = elements.length) {\n    let ans = [];\n    const combine = (step, set, size) => {\n        if (set.length === size) {\n            ans.push([...set]);\n            return;\n        }\n        if (step >= elements.length) {\n            return;\n        }\n        combine(step + 1, [...set, elements[step]], size);\n        combine(step + 1, set, size);\n    };\n    for (let i = start; i <= end; i++) {\n        combine(0, [], i);\n    }\n    return ans;\n}\nexport function normalize(frequencyList) {\n    let sum = 0;\n    for (let f of frequencyList) {\n        sum += f;\n    }\n    return frequencyList.map(f => f / sum);\n}\nexport const entropy = (probabilityList) => {\n    let sum = 0;\n    for (let p of probabilityList) {\n        sum += p * Math.log2(p);\n    }\n    return -sum;\n};\nexport const gini = (probabilityList) => {\n    let sum = 0;\n    for (let p of probabilityList) {\n        sum += p * (1 - p);\n    }\n    return sum;\n};\n","/**\n *\n * @param matrix adjmatrix\n */\nfunction turnAdjMatrix2List(matrix) {\n    // only for the special matrix here(corelational matrix)\n    let edges = [];\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = i + 1; j < matrix[i].length; j++) {\n            edges.push([[i, j], Math.abs(matrix[i][j])]);\n        }\n    }\n    return edges;\n}\nfunction find(parents, n) {\n    return parents[n] === n ? n : parents[n] = find(parents, parents[n]);\n}\nfunction union(parents, n1, n2) {\n    let p1 = find(parents, n1);\n    let p2 = find(parents, n2);\n    parents[p1] = p2;\n    // I'm too tired. this is just a tmp lazy solution.... will be fixed later.\n    // may check and prove whether it's necessary.\n    find(parents, n1);\n    find(parents, n2);\n}\nfunction findWithEffect(parents, sizes, n) {\n    if (parents[n] === n) {\n        return n;\n    }\n    parents[n] = findWithEffect(parents, sizes, parents[n]);\n    sizes[n] = sizes[parents[n]];\n    return parents[n];\n}\nfunction unionWithEffect(parents, sizes, n1, n2) {\n    let p1 = findWithEffect(parents, sizes, n1);\n    let p2 = findWithEffect(parents, sizes, n2);\n    let size1 = sizes[p1];\n    let size2 = sizes[p2];\n    parents[p1] = p2;\n    sizes[p1] = sizes[p2] = size1 + size2;\n    findWithEffect(parents, sizes, n1);\n    findWithEffect(parents, sizes, n2);\n}\n/**\n * maxiumn spanning tree\n * @param matrix adjmatrix\n * @param groupNumber number of group generated by clustering\n */\nfunction kruskal(matrix, groupNumber, threshold = 0) {\n    const edges = turnAdjMatrix2List(matrix);\n    edges.sort((a, b) => b[1] - a[1]);\n    const parents = matrix.map((m, i) => i);\n    for (let edge of edges) {\n        if (find(parents, edge[0][0]) !== find(parents, edge[0][1])) {\n            union(parents, edge[0][0], edge[0][1]);\n        }\n        for (let i = 0; i < parents.length; i++) {\n            parents[i] = find(parents, i);\n        }\n        let set = new Set(parents);\n        if (set.size <= groupNumber || edge[1] < threshold) {\n            break;\n        }\n    }\n    let groups = new Map();\n    for (let i = 0; i < parents.length; i++) {\n        if (!groups.has(parents[i])) {\n            groups.set(parents[i], []);\n        }\n        groups.get(parents[i]).push(i);\n    }\n    return groups;\n}\n// todo: delete kruskal with limit size, use largest size to limit it(uncontrolled group number but better), need discuss.\n/**\n *\n * @param matrix\n * @param limitSize max size of each group\n */\nfunction kruskalWithLimitSize(matrix, limitSize) {\n    const edges = turnAdjMatrix2List(matrix);\n    edges.sort((a, b) => b[1] - a[1]);\n    const parents = matrix.map((m, i) => i);\n    const sizes = matrix.map(() => 1);\n    for (let edge of edges) {\n        if (findWithEffect(parents, sizes, edge[0][0]) !== findWithEffect(parents, sizes, edge[0][1])) {\n            if (sizes[edge[0][0]] + sizes[edge[0][1]] > limitSize) {\n                continue;\n            }\n            unionWithEffect(parents, sizes, edge[0][0], edge[0][1]);\n        }\n        for (let i = 0; i < parents.length; i++) {\n            parents[i] = findWithEffect(parents, sizes, i);\n        }\n        let set = new Set(parents);\n        if (set.size === 1) {\n            break;\n        }\n    }\n    let groups = new Map();\n    for (let i = 0; i < parents.length; i++) {\n        if (!groups.has(parents[i])) {\n            groups.set(parents[i], []);\n        }\n        groups.get(parents[i]).push(i);\n    }\n    return groups;\n}\nexport function kruskalMSTWithLimitSize(matrix, limitSize = 4) {\n    const edges = turnAdjMatrix2List(matrix);\n    edges.sort((a, b) => b[1] - a[1]);\n    const edgesInMST = [];\n    const parents = matrix.map((m, i) => i);\n    const cloneParents = matrix.map((m, i) => i);\n    const sizes = matrix.map(() => 1);\n    for (let edge of edges) {\n        if (findWithEffect(parents, sizes, edge[0][0]) !== findWithEffect(parents, sizes, edge[0][1])) {\n            if (sizes[edge[0][0]] + sizes[edge[0][1]] > limitSize) {\n                if (find(cloneParents, edge[0][0]) !== find(cloneParents, edge[0][1])) {\n                    edgesInMST.push([edge[0], edge[1], true]);\n                    union(cloneParents, edge[0][0], edge[0][1]);\n                }\n                continue;\n            }\n            unionWithEffect(parents, sizes, edge[0][0], edge[0][1]);\n            // fuck typescript\n            // edgesInMST.push([...edge, inCutEdge]);\n            edgesInMST.push([edge[0], edge[1], false]);\n        }\n        for (let i = 0; i < parents.length; i++) {\n            parents[i] = findWithEffect(parents, sizes, i);\n            cloneParents[i] = find(cloneParents, i);\n        }\n        let set = new Set(parents);\n        if (set.size === 1) {\n            break;\n        }\n    }\n    return { edgesInMST, groups: parents };\n}\n/**\n *\n * @param matrix\n * @param groupNumber number of group generated by clustering\n */\nexport function kruskalMST(matrix, groupNumber = 4, threshold = 0) {\n    const edges = turnAdjMatrix2List(matrix);\n    edges.sort((a, b) => b[1] - a[1]);\n    const edgesInMST = [];\n    const parents = matrix.map((m, i) => i);\n    let groups = [...parents];\n    let inCutEdge = false;\n    for (let edge of edges) {\n        if (find(parents, edge[0][0]) !== find(parents, edge[0][1])) {\n            union(parents, edge[0][0], edge[0][1]);\n            // fuck typescript\n            // edgesInMST.push([...edge, inCutEdge]);\n            edgesInMST.push([edge[0], edge[1], inCutEdge]);\n        }\n        for (let i = 0; i < parents.length; i++) {\n            parents[i] = find(parents, i);\n        }\n        let set = new Set(parents);\n        // TODO:\n        // + use kruskalMST instead of kruskal.\n        if (set.size <= groupNumber || edge[1] < threshold) {\n            inCutEdge = true;\n        }\n        else {\n            groups = [...parents];\n        }\n        if (set.size === 1) {\n            break;\n        }\n    }\n    return { edgesInMST, groups };\n}\nfunction cluster({ matrix, measures, method = 'kruskal', groupMaxSize = 4, limitSize = false, threshold = 0 }) {\n    // const groups = kruskal({ matrix, groupMaxSize });\n    let groups;\n    if (limitSize) {\n        groups = kruskalWithLimitSize(matrix, groupMaxSize);\n    }\n    else {\n        groups = kruskal(matrix, groupMaxSize, threshold);\n    }\n    let ans = [];\n    for (let meas of groups.values()) {\n        ans.push(meas.map(meaIndex => measures[meaIndex]));\n    }\n    return ans;\n}\nexport default cluster;\n","import { getMeaSetsBasedOnClusterGroups, getDimClusterGroups } from './subspaces';\nimport { CrammersVThreshold, PearsonCorrelation } from './config';\nimport { Outier } from '../ml/index';\nimport { getCombination, linearMapPositive } from '../statistics/index';\nimport { CHANNEL } from '../constant';\nimport { entropy, normalize } from '../statistics/index';\nimport aggregate from 'cube-core';\nimport { oneDLinearRegression } from '../statistics/index';\nimport { GroupIntention } from \"./intention/groups\";\nconst SPLITER = '=;=';\nfunction crossGroups(dimensionGroups, measureGroups) {\n    let viewSpaces = [];\n    for (let dimensions of dimensionGroups) {\n        for (let measures of measureGroups) {\n            viewSpaces.push({\n                dimensions,\n                measures\n            });\n        }\n    }\n    return viewSpaces;\n}\nfunction getDimSetsFromClusterGroups(groups) {\n    let dimSets = [];\n    for (let group of groups) {\n        let combineDimSet = getCombination(group, 1, CHANNEL.maxDimensionNumber);\n        dimSets.push(...combineDimSet);\n    }\n    return dimSets;\n}\nfunction getCombinationFromClusterGroups(groups, limitSize = CHANNEL.maxDimensionNumber) {\n    let fieldSets = [];\n    for (let group of groups) {\n        let combineFieldSet = getCombination(group, 1, limitSize);\n        fieldSets.push(...combineFieldSet);\n    }\n    return fieldSets;\n}\nexport const getGeneralIntentionSpace = async function (aggData, dimensions, measures) {\n    let score = 0;\n    let significance = 0;\n    for (let mea of measures) {\n        let fL = aggData.map(r => r[mea]);\n        let pL = normalize(linearMapPositive(fL));\n        let value = entropy(pL);\n        score += value;\n        significance += value / Math.log2(fL.length);\n    }\n    score /= measures.length;\n    significance /= measures.length;\n    significance = 1 - significance;\n    return {\n        dimensions,\n        measures,\n        type: 'default_general',\n        score,\n        impurity: score,\n        significance,\n        order: 'asc'\n    };\n};\nexport const getOutlierIntentionSpace = async function getOutlierIntentionSpace(aggData, dimensions, measures) {\n    let iForest = new Outier.IsolationForest([], measures, aggData);\n    iForest.buildIsolationForest();\n    let scoreList = iForest.estimateOutierScore();\n    let maxIndex = 0;\n    let score = 0;\n    for (let i = 0; i < scoreList.length; i++) {\n        if (scoreList[i] > score) {\n            score = scoreList[i];\n            maxIndex = i;\n        }\n    }\n    let des = {};\n    dimensions.concat(measures).forEach(mea => { des[mea] = aggData[maxIndex][mea]; });\n    return {\n        dimensions,\n        measures,\n        score,\n        significance: score,\n        order: 'desc',\n        description: des\n    };\n};\nexport const getTrendIntentionSpace = async function (aggData, dimensions, measures) {\n    if (dimensions.length !== 1)\n        return null;\n    let orderedData = [...aggData];\n    orderedData.sort((a, b) => {\n        if (a[dimensions[0]] > b[dimensions[0]])\n            return 1;\n        if (a[dimensions[0]] === b[dimensions[0]])\n            return 0;\n        if (a[dimensions[0]] < b[dimensions[0]])\n            return -1;\n    });\n    let score = 0;\n    for (let mea of measures) {\n        let linearModel = new oneDLinearRegression(orderedData, dimensions[0], mea);\n        linearModel.normalizeDimensions(dimensions);\n        score += linearModel.significance();\n    }\n    score /= measures.length;\n    return {\n        dimensions,\n        measures,\n        score,\n        significance: score,\n        order: 'desc'\n    };\n};\nexport const getGroupIntentionSpace = async function (aggData, dimensions, measures) {\n    if (dimensions.length < 2)\n        return null;\n    let score = 0;\n    let groupIntention = new GroupIntention({\n        dataSource: aggData,\n        dimensions,\n        measures,\n        K: 8\n    });\n    score = groupIntention.getSignificance(measures.concat(dimensions.slice(0, -1)), dimensions.slice(-1));\n    return {\n        dimensions,\n        measures,\n        score,\n        significance: score,\n        order: 'desc'\n    };\n};\n// export const IntentionWorkerCollection: Map<string, IntentionWorker> = new Map();\nexport var DefaultIWorker;\n(function (DefaultIWorker) {\n    DefaultIWorker[\"outlier\"] = \"default_outlier\";\n    DefaultIWorker[\"cluster\"] = \"default_group\";\n    DefaultIWorker[\"trend\"] = \"default_trend\";\n})(DefaultIWorker || (DefaultIWorker = {}));\nexport class IntentionWorkerCollection {\n    constructor() {\n        this.workers = new Map();\n    }\n    register(name, iWorker) {\n        if (this.workers.has(name)) {\n            throw new Error(`There has been a worker named: ${name} already.`);\n        }\n        else {\n            this.workers.set(name, [true, iWorker]);\n        }\n    }\n    enable(name, status) {\n        if (!this.workers.has(name)) {\n            throw new Error(`Intention Worker \"${name}\" does not exist.`);\n        }\n        else {\n            let iWorkerWithStatus = this.workers.get(name);\n            iWorkerWithStatus[0] = status;\n            this.workers.set(name, iWorkerWithStatus);\n        }\n    }\n    each(func) {\n        for (let [name, iWorker] of this.workers) {\n            if (iWorker[0]) {\n                func(iWorker[1], name);\n            }\n        }\n    }\n    static init(props = { withDefaultIWorkers: true }) {\n        const { withDefaultIWorkers = true } = props;\n        if (!IntentionWorkerCollection.colletion) {\n            IntentionWorkerCollection.colletion = new IntentionWorkerCollection();\n            if (withDefaultIWorkers) {\n                IntentionWorkerCollection.colletion.register(DefaultIWorker.outlier, getOutlierIntentionSpace);\n                IntentionWorkerCollection.colletion.register(DefaultIWorker.cluster, getGroupIntentionSpace);\n                IntentionWorkerCollection.colletion.register(DefaultIWorker.trend, getTrendIntentionSpace);\n            }\n        }\n        for (let key in DefaultIWorker) {\n            IntentionWorkerCollection.colletion.enable(DefaultIWorker[key], withDefaultIWorkers);\n        }\n        return IntentionWorkerCollection.colletion;\n    }\n}\nexport async function getIntentionSpaces(cubePool, viewSpaces, Collection) {\n    let ansSpace = [];\n    for (let space of viewSpaces) {\n        const { dimensions, measures } = space;\n        let key = dimensions.join(SPLITER);\n        if (cubePool.has(key)) {\n            let aggData = cubePool.get(key);\n            let generalSpace = await getGeneralIntentionSpace(aggData, dimensions, measures);\n            Collection.each(async (iWorker, name) => {\n                let iSpace = await iWorker(aggData, dimensions, measures);\n                if (iSpace !== null) {\n                    iSpace.type = name;\n                    iSpace.impurity = generalSpace.impurity;\n                    ansSpace.push(iSpace);\n                }\n            });\n        }\n    }\n    return ansSpace;\n}\nexport async function getVisSpaces(props) {\n    const { dataSource, dimensions, measures, collection, dimension_correlation_threshold = CrammersVThreshold, measure_correlation_threshold = PearsonCorrelation.strong, max_dimension_num_in_view = 3, max_measure_num_in_view = 3, } = props;\n    // 1. get dimension cluster groups.\n    // 2. get measure cluster groups.\n    // 3. get dimension groups * measure groups = subspaces + aggregate\n    // 4. calculate each subspace intention score (entropy, outlier, trend for temporal & oridinal field)\n    // 5. filter each intend subspaces with threadshold\n    // 6.manage those spaces / order them.\n    let visableDimensions = dimensions; //.filter(dim => !isFieldUnique(dataSource, dim));\n    let dimensionGroups = getDimClusterGroups(dataSource, visableDimensions, dimension_correlation_threshold);\n    // let dimensionSets = getDimSetsFromClusterGroups(dimensionGroups);\n    let dimensionSets = getCombinationFromClusterGroups(dimensionGroups, max_dimension_num_in_view);\n    let measureGroups = getMeaSetsBasedOnClusterGroups(dataSource, measures, measure_correlation_threshold);\n    let measureSets = getCombinationFromClusterGroups(measureGroups, max_measure_num_in_view);\n    let viewSpaces = crossGroups(dimensionSets, measureSets);\n    let cubePool = new Map();\n    // for (let group of dimensionGroups) {\n    // todo: similar cuboids computation using cube-core\n    let t0 = new Date().getTime();\n    for (let group of dimensionSets) {\n        let key = group.join(SPLITER);\n        let aggData = aggregate({\n            dataSource,\n            dimensions: group,\n            measures,\n            asFields: measures,\n            operator: 'sum'\n        });\n        cubePool.set(key, aggData);\n    }\n    let t1 = new Date().getTime();\n    console.log('cube cost', t1 - t0);\n    cubePool.set('*', dataSource);\n    const usedCollection = collection || IntentionWorkerCollection.init();\n    ;\n    // usedCollection.enable(DefaultIWorker.cluster, false);\n    let ansSpace = await getIntentionSpaces(cubePool, viewSpaces, usedCollection);\n    return ansSpace;\n}\n","import { isFieldTime, isFieldContinous, memberCount, isFieldCategory, deepcopy, groupContinousField, groupCategoryField } from '../utils/index';\nimport { normalize, entropy } from '../statistics/index';\nimport { isUniformDistribution } from '../distribution';\nconst MIN_QUAN_MEMBER_SIZE = 25;\n/**\n *\n * @param dataSource\n * @param field\n * todo: should accept BIField type and calculate the semantic type basic on it.\n */\nexport function getFieldType(dataSource, field) {\n    if (isFieldTime(dataSource, field)) {\n        return 'temporal';\n    }\n    else if (isFieldContinous(dataSource, field)) {\n        // Todo:\n        // here is only a tmp solution. we still hope to divided ordinal type and quantitative type.\n        // if (memberCount(dataSource, field).length > MIN_QUAN_MEMBER_SIZE) {\n        //   return 'quantitative'\n        // } else {\n        //   return 'ordinal';\n        // }\n        return 'quantitative';\n    }\n    else if (isFieldCategory(dataSource, field)) {\n        // isFieldCategory is a safety checking here, for sometimes dirty data value can be object.\n        return 'nominal';\n    }\n    else {\n        // todo do something(like cleaning)\n        return 'nominal';\n    }\n}\nexport function getAllFieldTypes(dataSource, fields) {\n    let fieldsWithType = [];\n    for (let field of fields) {\n        fieldsWithType.push({\n            name: field,\n            type: getFieldType(dataSource, field)\n        });\n    }\n    return fieldsWithType;\n}\nexport function getFieldDistribution(dataSource, field) {\n    let members = memberCount(dataSource, field);\n    // members.sort((a, b) => a[1] - b[1]);\n    return members.map(m => {\n        return { memberName: m[0], count: m[1] };\n    });\n}\nexport function getAllFieldsDistribution(dataSource, fields) {\n    let fieldsDistribution = [];\n    for (let field of fields) {\n        fieldsDistribution.push({\n            fieldName: field,\n            distribution: getFieldDistribution(dataSource, field)\n        });\n    }\n    return fieldsDistribution;\n}\nexport function getFieldEntropy(dataSource, field) {\n    const members = memberCount(dataSource, field);\n    const frequencyList = members.map(m => m[1]);\n    const probabilityList = normalize(frequencyList);\n    const fieldEntropy = entropy(probabilityList);\n    const maxEntropy = Math.log2(members.length);\n    return {\n        fieldName: field,\n        entropy: fieldEntropy,\n        maxEntropy\n    };\n}\nexport function getAllFieldsEntropy(dataSource, fields) {\n    let fieldEntropyList = [];\n    for (let field of fields) {\n        fieldEntropyList.push(getFieldEntropy(dataSource, field));\n    }\n    return fieldEntropyList;\n}\nexport function groupFields(dataSource, fields) {\n    let groupedData = deepcopy(dataSource);\n    let newFields = [];\n    for (let field of fields) {\n        let newFieldName = `${field.name}(group)`;\n        if (field.type === 'quantitative' && memberCount(dataSource, field.name).length > MIN_QUAN_MEMBER_SIZE * 2) {\n            if (!isUniformDistribution(dataSource, field.name)) {\n                groupedData = groupContinousField({\n                    dataSource: groupedData,\n                    field: field.name,\n                    newField: newFieldName,\n                    groupNumber: 8\n                });\n                newFields.push({\n                    name: newFieldName,\n                    type: 'ordinal'\n                });\n            }\n        }\n        else if ((field.type === 'ordinal' || field.type === 'nominal') && memberCount(dataSource, field.name).length > MIN_QUAN_MEMBER_SIZE) {\n            if (!isUniformDistribution(dataSource, field.name)) {\n                groupedData = groupCategoryField({\n                    dataSource: groupedData,\n                    field: field.name,\n                    newField: newFieldName,\n                    groupNumber: 8\n                });\n                newFields.push({\n                    name: newFieldName,\n                    type: field.type\n                });\n            }\n        }\n    }\n    return {\n        groupedData,\n        fields,\n        newFields\n    };\n}\n","/**\n * \n * @param {task} task is a function \n */\nexport function timer (task) {\n  return function (e) {\n    let startTime = new Date().getTime();\n    try {\n      task(e);\n    } finally {\n      let cost = new Date().getTime() - startTime;\n      console.log(`Task [${task.name}] cost ${cost} ms.`)\n    }\n  }\n}","/* eslint no-restricted-globals: 0 */\nimport { UnivariateSummary } from 'visual-insights';\nimport { timer } from './timer';\nconst groupFields = (e) => {\n  try {\n    const { dataSource, fields } = e.data;\n    const result = UnivariateSummary.groupFields(dataSource, fields);\n    self.postMessage({\n      success: true,\n      data: result\n    })\n  } catch (error) {\n    self.postMessage({\n      success: false,\n      message: error.toString()\n    })\n  }\n}\n\nself.addEventListener('message', timer(groupFields), false);"],"sourceRoot":""}